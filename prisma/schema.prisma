generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
}

enum Role {
  USER
  ADMIN
  BANNED
}

// Subscription Tiers - "Vriend van de Liefde" Model
enum SubscriptionTier {
  FREE      // Basis - Gratis
  PLUS      // Liefde Plus - ‚Ç¨9,95/maand
  COMPLETE  // Liefde Compleet - ‚Ç¨24,95/3 maanden
}

// Wie zoekt de gebruiker
enum LookingFor {
  MALE
  FEMALE
  BOTH
}

// Onboarding mode - bepaalt hoeveel vragen
enum OnboardingMode {
  SIMPLE    // Minimale vragen (snelle flow)
  STANDARD  // Standaard flow (aanbevolen)
  ADVANCED  // Uitgebreide flow (beste matches)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  passwordHash  String?
  bio           String?   @db.Text
  birthDate     DateTime?
  gender        Gender?
  city          String?
  postcode      String?
  interests     String?
  preferences   String?
  profileImage  String?
  voiceIntro    String?
  role          Role      @default(USER)
  isVerified    Boolean   @default(false)
  safetyScore   Int       @default(100)
  hasAcceptedTerms Boolean @default(false)
  latitude      Float?
  longitude     Float?
  twoFactorSecret String?
  twoFactorEnabled Boolean @default(false)
  twoFactorBackupCodes String? @db.Text
  // Real-time presence
  lastSeen      DateTime?
  isOnline      Boolean   @default(false)
  // Photo verification
  isPhotoVerified Boolean @default(false)
  verifiedAt    DateTime?

  // Subscription & Credits - "Vriend van de Liefde" Model
  subscriptionTier SubscriptionTier @default(FREE)
  credits          Int              @default(0) // Superberichten credits
  monthlySupermessages Int          @default(0) // Maandelijkse gratis superberichten (voor COMPLETE)
  monthlySupermessagesReset DateTime? // Wanneer maandelijkse credits resetten

  // Onboarding & Profile Completion
  lookingFor        LookingFor?                    // Wie zoekt de gebruiker
  minAgePreference  Int              @default(18)  // Minimum leeftijd voorkeur
  maxAgePreference  Int              @default(99)  // Maximum leeftijd voorkeur
  onboardingStep    Int              @default(0)   // Huidige stap in onboarding (0 = niet gestart)
  onboardingMode    OnboardingMode?                // Gekozen onboarding mode
  profileComplete   Boolean          @default(false) // Is het profiel compleet?
  rulesAccepted     Boolean          @default(false) // Heeft gedragsregels geaccepteerd

  // üåç Passport Mode - Virtual location for swiping in other cities
  passportCity      String?          // Virtual city name
  passportLatitude  Float?           // Virtual latitude
  passportLongitude Float?           // Virtual longitude
  passportExpiresAt DateTime?        // When passport expires

  // üïµÔ∏è Incognito Mode - Browse without appearing in discover
  incognitoMode     Boolean          @default(false)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  accounts      Account[]
  sessions      Session[]
  photos        Photo[]
  outgoingSwipes Swipe[]  @relation("Swiper")
  incomingSwipes Swipe[]  @relation("Swiped")
  matches1       Match[]  @relation("User1")
  matches2       Match[]  @relation("User2")
  messages       Message[]
  posts          Post[]
  comments       Comment[]
  subscriptions  Subscription[]
  reportsSent    Report[]  @relation("Reporter")
  reportsReceived Report[] @relation("Reported")
  blocksSent     Block[]   @relation("Blocker")
  blocksReceived Block[]   @relation("Blocked")
  notifications  Notification[]
  // AI Matching relations
  matchScoresAsUser    MatchScore[] @relation("MatchScoreUser")
  matchScoresAsTarget  MatchScore[] @relation("MatchScoreTarget")
  embedding            UserEmbedding?
  // Engagement features
  pushSubscriptions    PushSubscription[]
  profileViewsSent     ProfileView[] @relation("ProfileViewer")
  profileViewsReceived ProfileView[] @relation("ProfileViewed")
  profileBoosts        ProfileBoost[]
  profilePrompts       ProfilePrompt[]
  // Superberichten (Love Notes)
  sentSuperMessages     SuperMessage[] @relation("SuperMessageSender")
  receivedSuperMessages SuperMessage[] @relation("SuperMessageReceiver")
  // Veiligheid: Spending Limit
  spendingLimit        SpendingLimit?
  // Credit aankopen historie
  creditPurchases      CreditPurchase[]
  // üì∏ Stories
  stories              Story[]
  storyViews           StoryView[]
  // üõ°Ô∏è Safety & Verification
  photoVerifications   PhotoVerification[]

  // Privacy & GDPR Consent
  privacyPolicyAccepted    Boolean   @default(false)
  privacyPolicyVersion     String?   // Welke versie van privacy policy geaccepteerd
  privacyPolicyAcceptedAt  DateTime?
  marketingEmailsConsent   Boolean   @default(false)

  @@index([gender])
  @@index([birthDate])
  @@index([city])
  @@index([profileImage])
  @@index([createdAt])
  @@index([gender, birthDate, city])
  @@index([role])
  @@index([latitude, longitude])
  @@index([email])
  @@index([isOnline])
  @@index([isPhotoVerified])
  @@index([subscriptionTier])
  @@index([profileComplete])
  @@index([onboardingStep])
  @@index([incognitoMode])
  @@index([passportCity])
}

model Photo {
  id        String   @id @default(cuid())
  url       String
  order     Int      @default(0)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

model Swipe {
  id          String   @id @default(cuid())
  swiperId    String
  swiper      User     @relation("Swiper", fields: [swiperId], references: [id], onDelete: Cascade)
  swipedId    String
  swiped      User     @relation("Swiped", fields: [swipedId], references: [id], onDelete: Cascade)
  isLike      Boolean
  isSuperLike Boolean  @default(false)
  createdAt   DateTime @default(now())
  @@unique([swiperId, swipedId])
  @@index([swiperId])
  @@index([swipedId])
  @@index([swipedId, isLike])
  @@index([swiperId, isSuperLike, createdAt])
}

model Match {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  user1Id   String
  user1     User      @relation("User1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2Id   String
  user2     User      @relation("User2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages  Message[]
  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Message {
  id        String   @id @default(cuid())
  content   String?  @db.Text
  audioUrl  String?
  gifUrl    String?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  senderId  String
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  matchId   String
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@index([matchId])
  @@index([senderId])
  @@index([createdAt])
  @@index([matchId, createdAt])
  @@index([matchId, read])
}

model Category {
  id          String   @id @default(cuid())
  name        String
  icon        String
  description String?
  color       String
  posts       Post[]
}

model Post {
  id          String    @id @default(cuid())
  title       String
  content     String    @db.Text
  slug        String?   @unique
  excerpt     String?
  featuredImage String?
  published   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  authorId    String
  author      User      @relation(fields: [authorId], references: [id])
  categoryId  String
  category    Category  @relation(fields: [categoryId], references: [id])
  comments    Comment[]
  likeCount   Int       @default(0)

  @@index([authorId])
  @@index([categoryId])
  @@index([published, createdAt])
}

model Comment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  createdAt DateTime @default(now())
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([authorId])
  @@index([postId, createdAt])
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expires])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  @@unique([identifier, token])
}

model Subscription {
  id              String    @id @default(cuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id])
  plan            String
  status          String
  multisafepayId  String?
  recurringId     String?   // For recurring payments
  startDate       DateTime  @default(now())
  endDate         DateTime?
  cancelledAt     DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([userId, status])
  @@index([endDate])
}

model Report {
  id          String   @id @default(cuid())
  reporterId  String
  reporter    User     @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedId  String
  reported    User     @relation("Reported", fields: [reportedId], references: [id], onDelete: Cascade)
  reason      String
  description String?
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?

  @@index([reporterId])
  @@index([reportedId])
  @@index([status])
  @@index([status, createdAt])
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blocker   User     @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedId String
  blocked   User     @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String
  title     String
  message   String
  isRead    Boolean  @default(false)
  relatedId String?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@index([userId, isRead])
  @@index([userId, createdAt])
}

model PasswordReset {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expires   DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email])
  @@index([token])
}

model EmailLog {
  id            String    @id @default(cuid())
  userId        String?
  email         String
  type          String
  category      String
  subject       String
  status        String
  sentAt        DateTime  @default(now())
  deliveredAt   DateTime?
  openedAt      DateTime?
  clickedAt     DateTime?
  bouncedAt     DateTime?
  errorMessage  String?

  @@index([userId])
  @@index([email])
  @@index([type, category])
  @@index([sentAt])
  @@index([status])
}

// ============================================
// AI SMART MATCHING MODELS
// ============================================

model MatchScore {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation("MatchScoreUser", fields: [userId], references: [id], onDelete: Cascade)
  targetUserId  String
  targetUser    User     @relation("MatchScoreTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  overallScore  Float
  interestScore Float
  bioScore      Float
  locationScore Float
  activityScore Float
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, targetUserId])
  @@index([userId])
  @@index([targetUserId])
  @@index([userId, overallScore])
}

model UserEmbedding {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  embedding Json
  bioHash   String?
  updatedAt DateTime @updatedAt
}

// ============================================
// ENGAGEMENT & PREMIUM FEATURES
// ============================================

model PushSubscription {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint     String   @unique
  p256dh       String
  auth         String
  userAgent    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  lastUsedAt   DateTime @default(now())

  @@index([userId])
  @@index([isActive])
}

model ProfileView {
  id        String   @id @default(cuid())
  viewerId  String
  viewer    User     @relation("ProfileViewer", fields: [viewerId], references: [id], onDelete: Cascade)
  viewedId  String
  viewed    User     @relation("ProfileViewed", fields: [viewedId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([viewerId, viewedId])
  @@index([viewerId])
  @@index([viewedId])
  @@index([viewedId, createdAt])
}

model ProfileBoost {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  startedAt DateTime @default(now())
  expiresAt DateTime
  isActive  Boolean  @default(true)

  @@index([userId])
  @@index([isActive, expiresAt])
}

model SwipeHistory {
  id        String   @id @default(cuid())
  swipeId   String   @unique
  swiperId  String
  swipedId  String
  isLike    Boolean
  swipedAt  DateTime
  undoneAt  DateTime?
  createdAt DateTime @default(now())

  @@index([swiperId, createdAt])
}

// ============================================
// PRICING & CREDITS SYSTEM - "Vriend van de Liefde"
// ============================================

// Superbericht - Direct contact zonder match (voorheen "Love Notes")
model SuperMessage {
  id        String   @id @default(cuid())
  senderId  String
  sender    User     @relation("SuperMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  targetId  String
  target    User     @relation("SuperMessageReceiver", fields: [targetId], references: [id], onDelete: Cascade)
  message   String?  @db.Text // Optioneel persoonlijk bericht
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([senderId])
  @@index([targetId])
  @@index([targetId, isRead])
  @@index([createdAt])
}

// Veiligheid: Dagelijkse bestedingslimiet (Circuit Breaker)
// Beschermt gebruikers tegen impulsief koopgedrag
model SpendingLimit {
  id           String   @id @default(cuid())
  userId       String   @unique
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  dailyLimit   Float    @default(20.00) // Max ‚Ç¨20 per dag uitgeven
  currentSpent Float    @default(0.00)  // Vandaag uitgegeven
  lastReset    DateTime @default(now()) // Wanneer currentSpent gereset is

  @@index([lastReset])
}

// Credit aankoop historie
model CreditPurchase {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  credits       Int      // Aantal gekochte credits
  amount        Float    // Betaald bedrag in euros
  paymentId     String?  // MultiSafePay of andere payment provider ID
  paymentMethod String?  // ideal, creditcard, etc.
  status        String   @default("pending") // pending, completed, failed, refunded
  createdAt     DateTime @default(now())
  completedAt   DateTime?

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// Subscription Payment - Uitgebreide tracking
model SubscriptionPayment {
  id              String   @id @default(cuid())
  subscriptionId  String
  amount          Float
  currency        String   @default("EUR")
  paymentId       String?  // Payment provider ID
  paymentMethod   String?
  status          String   @default("pending")
  createdAt       DateTime @default(now())
  paidAt          DateTime?

  @@index([subscriptionId])
  @@index([status])
}

// ============================================
// PRIVACY & GDPR COMPLIANCE
// ============================================

// Cookie consent tracking (AVG compliant)
model CookieConsent {
  id              String   @id @default(cuid())
  userId          String?  // Null voor anonieme bezoekers

  // Consent categories
  necessary       Boolean  @default(true)  // Altijd true (functionele cookies)
  analytics       Boolean  @default(false) // Opt-in vereist
  marketing       Boolean  @default(false) // Opt-in vereist

  // Metadata voor compliance
  consentVersion  String   @default("2.0") // Privacy policy versie
  ipAddress       String?
  userAgent       String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
}

// Consent history (audit trail - AVG vereiste Artikel 7)
model ConsentHistory {
  id              String   @id @default(cuid())
  userId          String?  // Null voor anonieme bezoekers
  consentId       String
  action          String   // 'granted', 'updated', 'revoked'
  categories      Json     // Snapshot van consent state
  ipAddress       String?
  userAgent       String?
  createdAt       DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@index([userId, createdAt])
}

// Data export requests (AVG Artikel 20 - Recht op dataportabiliteit)
model DataExportRequest {
  id          String    @id @default(cuid())
  userId      String
  status      String    @default("pending") // pending, processing, completed, failed
  downloadUrl String?   @db.Text // Long URL for secure download
  expiresAt   DateTime? // Download link expires after 7 days
  errorMessage String?  @db.Text
  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([userId])
  @@index([status])
  @@index([userId, status])
  @@index([createdAt])
}

// Account deletion requests (AVG Artikel 17 - Recht om vergeten te worden)
model AccountDeletionRequest {
  id              String    @id @default(cuid())
  userId          String    @unique
  reason          String?   @db.Text // Optionele reden voor verwijdering
  scheduledFor    DateTime  // 30 dagen in de toekomst (bedenktijd)
  cancelled       Boolean   @default(false)
  cancelledAt     DateTime?
  processedAt     DateTime? // Wanneer daadwerkelijk verwijderd
  createdAt       DateTime  @default(now())

  @@index([scheduledFor])
  @@index([cancelled])
}

// ============================================
// COUPON SYSTEM - Wereldklasse Marketing Tool
// ============================================

enum CouponType {
  PERCENTAGE    // Percentage korting (bijv. 20% off)
  FIXED_AMOUNT  // Vast bedrag korting (bijv. ‚Ç¨5 off)
  FREE_TRIAL    // Gratis proefperiode (bijv. 1 maand gratis)
}

enum CouponApplicableTo {
  ALL           // Geldt voor alles
  SUBSCRIPTION  // Alleen voor abonnementen
  CREDITS       // Alleen voor credit aankopen
}

model Coupon {
  id                String              @id @default(cuid())
  code              String              @unique // Couponcode (bijv. LOVE2024, NIEUW50)
  description       String?             @db.Text // Interne beschrijving voor admins

  // Discount settings
  type              CouponType
  value             Float               // Percentage (20) of bedrag (5.00)
  applicableTo      CouponApplicableTo  @default(ALL)
  applicablePlans   String?             // JSON array van plannen (bijv. ["PLUS", "COMPLETE"])

  // Restrictions
  minPurchaseAmount Float?              // Minimum aankoopbedrag
  maxDiscountCap    Float?              // Maximum kortingsbedrag (voor percentage coupons)

  // Usage limits
  maxTotalUses      Int?                // Totaal aantal keer te gebruiken (null = onbeperkt)
  maxUsesPerUser    Int                 @default(1) // Max gebruik per gebruiker
  currentTotalUses  Int                 @default(0) // Aantal keer gebruikt

  // Validity period
  validFrom         DateTime            @default(now())
  validUntil        DateTime?           // Null = geen vervaldatum

  // Status
  isActive          Boolean             @default(true)

  // Metadata
  createdBy         String?             // Admin user ID die coupon aanmaakte
  notes             String?             @db.Text // Extra notities voor admins

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  // Relations
  usages            CouponUsage[]

  @@index([code])
  @@index([isActive])
  @@index([validFrom, validUntil])
  @@index([applicableTo])
  @@index([createdAt])
}

// Coupon usage tracking
model CouponUsage {
  id              String   @id @default(cuid())
  couponId        String
  coupon          Coupon   @relation(fields: [couponId], references: [id], onDelete: Cascade)
  userId          String

  // Usage details
  orderType       String   // "subscription" of "credits"
  orderId         String?  // Subscription ID of CreditPurchase ID
  discountAmount  Float    // Werkelijke kortingsbedrag toegepast
  originalAmount  Float    // Originele prijs
  finalAmount     Float    // Uiteindelijke prijs na korting

  usedAt          DateTime @default(now())

  @@index([couponId])
  @@index([userId])
  @@index([couponId, userId])
  @@index([usedAt])
}

// ============================================
// PROFILE PROMPTS - Hinge-style Q&A
// ============================================

model ProfilePrompt {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question  String   // De vraag/prompt
  answer    String   @db.Text // Het antwoord van de gebruiker
  order     Int      @default(0) // Volgorde op profiel
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([userId, order])
}

// ============================================
// üì∑ PHOTO VERIFICATION
// ============================================

model PhotoVerification {
  id              String    @id @default(cuid())
  userId          String
  photoUrl        String
  pose            String    @default("neutral")
  status          String    @default("pending") // pending, approved, rejected
  submittedAt     DateTime  @default(now())
  reviewedAt      DateTime?
  reviewedBy      String?
  rejectionReason String?

  @@index([userId])
  @@index([status])
}

// ============================================
// üì∏ STORIES - 24-hour content like Instagram
// ============================================

enum StoryMediaType {
  PHOTO
  VIDEO
}

model Story {
  id        String         @id @default(cuid())
  userId    String
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  mediaUrl  String         // URL to the media file
  mediaType StoryMediaType @default(PHOTO)
  caption   String?        // Optional caption
  createdAt DateTime       @default(now())
  expiresAt DateTime       // 24 hours after creation
  viewCount Int            @default(0)

  // Views tracking
  views     StoryView[]

  @@index([userId])
  @@index([expiresAt])
  @@index([userId, expiresAt])
  @@index([createdAt])
}

model StoryView {
  id        String   @id @default(cuid())
  storyId   String
  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  viewerId  String
  viewer    User     @relation(fields: [viewerId], references: [id], onDelete: Cascade)
  viewedAt  DateTime @default(now())

  @@unique([storyId, viewerId]) // Each user can only view once
  @@index([storyId])
  @@index([viewerId])
}


// Photo Verification for safety
model PhotoVerification {
  id               String    @id @default(cuid())
  userId           String
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  photoUrl         String    // Selfie URL
  pose             String    @default("neutral") // Pose requested (for AI verification)
  status           String    @default("pending") // pending, approved, rejected
  submittedAt      DateTime  @default(now())
  reviewedAt       DateTime?
  reviewedBy       String?   // Admin user ID who reviewed
  rejectionReason  String?   @db.Text

  @@index([userId])
  @@index([status])
  @@index([status, submittedAt])
}

// Profile views tracking (for "Who viewed me" premium feature)
model ProfileView {
  id        String   @id @default(cuid())
  viewerId  String
  viewer    User     @relation("ProfileViewer", fields: [viewerId], references: [id], onDelete: Cascade)
  viewedId  String
  viewed    User     @relation("ProfileViewed", fields: [viewedId], references: [id], onDelete: Cascade)
  viewedAt  DateTime @default(now())

  @@unique([viewerId, viewedId, viewedAt]) // Prevent duplicate views at same timestamp
  @@index([viewerId])
  @@index([viewedId])
  @@index([viewedId, viewedAt]) // For "recent viewers"
  @@index([viewedAt])
}
